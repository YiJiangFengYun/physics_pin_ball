{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/vector.ts","webpack:///./src/object.ts","webpack:///./src/bounds.ts","webpack:///./src/circle.ts","webpack:///./src/rectangle.ts","webpack:///./src/my_circle.ts","webpack:///./src/index.ts","webpack:///./src/world.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector","x","y","this","subVectors","vec1","vec2","result","addVectors","mulVectorMag","vec","magnitude","normalVector","copy","clone","normal","dotVectors","reflectVector","Error","dot","mulMag","target","sub","add","Math","sqrt","manitudeSquare","zero","vector_1","bounds_1","Obj","_pos","_bounds","Bounds","updatePos","minX","minY","maxX","maxY","intersectBounds","bounds1","bounds2","intersect","Circle","_super","_this","_radius","_setBounds","__extends","pos","bounds","radius","object_1","Rectangle","_width","_height","points","_points","POINT_COUNT","length","_setPoints","halfWidth","halfHeight","circle_1","rectangle_1","MyCircle","_velocity","collide","collided","targetCircle","myCircle","targetSquare","circleCenter","circleCenterX","circleCenterY","circleRadius","squareBounds","circlArea","findArea","areaX","areaY","velocity","point","pointHelper","circleRadiusSquare","__export","my_circle_1","World","time","objectCount","objects","myObj","addObj","removeObj","clear","step","dt","iterations","cachePosHelper","nextPosHelper","collisionResultHelper","collisionNormlHelper","reflectResultHelper","minDt","iteration","myBody","cachePos","nextPos","collisioned","collisionResult","collsionNormal","reflectResult","cacheMagnitude","nextPos_1"],"mappings":"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","file":"model.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","export class Vector {\r\n    public static subVectors(vec1:Vector, vec2:Vector, result?:Vector):Vector {\r\n        if (! result) result = new Vector();\r\n        result.x = vec1.x - vec2.x;\r\n        result.y = vec1.y - vec2.y;\r\n        return result;\r\n    }\r\n\r\n    public static addVectors(vec1:Vector, vec2:Vector, result?:Vector):Vector {\r\n        if (! result) result = new Vector();\r\n        result.x = vec1.x + vec2.x;\r\n        result.y = vec1.y + vec2.y;\r\n        return result;\r\n    }\r\n\r\n    public static mulVectorMag(vec:Vector, magnitude:number, result?:Vector):Vector {\r\n        if (! result) result = new Vector();\r\n        result.x = vec.x * magnitude;\r\n        result.y = vec.y * magnitude;\r\n        return result;\r\n    }\r\n\r\n    public static normalVector(vec:Vector, result?:Vector):Vector {\r\n        if (! result) result = vec.clone();\r\n        else result.copy(vec);\r\n        result.normal();\r\n        return result;\r\n    }\r\n\r\n    public static dotVectors(vec1:Vector, vec2:Vector):number {\r\n        return vec1.x * vec2.x + vec1.y * vec2.y;\r\n    }\r\n\r\n    public static reflectVector(vec:Vector, normal:Vector, result?:Vector):Vector {\r\n        if (! result) result = new Vector();\r\n        else if (result == vec) {\r\n            throw new Error(\"The result shouldn't be argument vec.\");\r\n        }\r\n        let dot = Vector.dotVectors(vec, normal);\r\n        result.copy(normal);\r\n        result.mulMag(dot * 2);\r\n        Vector.subVectors(vec, result, result);\r\n        return result;\r\n    }\r\n\r\n    x:number;\r\n    y:number;\r\n    constructor(x:number = 0, y:number = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    clone():Vector {\r\n        return new Vector(this.x, this.y);\r\n    }\r\n\r\n    copy(target:Vector):void {\r\n        this.x = target.x;\r\n        this.y = target.y;\r\n    }\r\n\r\n    sub(target:Vector):void {\r\n        this.x -= target.x;\r\n        this.y -= target.y;\r\n    }\r\n\r\n    add(target:Vector):void {\r\n        this.x += target.x;\r\n        this.y += target.y;\r\n    }\r\n\r\n    mulMag(magnitude:number):void {\r\n        this.x *= magnitude;\r\n        this.y *= magnitude;\r\n    }\r\n\r\n    magnitude():number {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    manitudeSquare():number {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        return x * x + y * y;\r\n    }\r\n\r\n    normal():void {\r\n        let magnitude = this.magnitude();\r\n        this.x /= magnitude;\r\n        this.y /= magnitude;\r\n    }\r\n\r\n    zero():void {\r\n        this.x = 0;\r\n        this.y = 0;\r\n    }\r\n}","import { Vector } from \"./vector\";\r\nimport { Bounds } from \"./bounds\";\r\n\r\nexport abstract class Obj {\r\n    protected _pos:Vector;\r\n    protected _bounds:Bounds;\r\n    constructor() {\r\n        this._pos = new Vector();\r\n        this._bounds = new Bounds();\r\n    }\r\n\r\n    get pos():Vector {\r\n        return this._pos;\r\n    }\r\n\r\n    set pos(value:Vector) {\r\n        this._pos.copy(value);\r\n    }\r\n\r\n    get bounds():Bounds {\r\n        return this._bounds;\r\n    }\r\n\r\n    updatePos(value?:Vector) {\r\n        if (value) {\r\n            this._pos = value;\r\n        }\r\n    }\r\n}","export class Bounds {\r\n    public static intersectBounds(bounds1:Bounds, bounds2:Bounds):boolean {\r\n        if (bounds1.minX > bounds2.maxX || bounds1.maxX < bounds2.minX || \r\n            bounds1.minY > bounds2.maxY || bounds1.maxY < bounds2.minY) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    minX:number;\r\n    minY:number;\r\n    maxX:number;\r\n    maxY:number;\r\n    constructor(minX:number = 0, minY:number = 0, maxX:number = 0, maxY:number = 0) {\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    }\r\n\r\n    intersect(target:Bounds):boolean {\r\n        return Bounds.intersectBounds(this, target);\r\n    }\r\n}","import { Obj } from \"./object\";\r\nimport { Bounds } from \"./bounds\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport class Circle extends Obj {\r\n    private _radius:number;\r\n    constructor() {\r\n        super();\r\n        this._radius = 0;\r\n        this._setBounds();\r\n    }\r\n\r\n    get radius():number {\r\n        return this._radius;\r\n    }\r\n\r\n    set radius(value:number) {\r\n        this._radius = value;\r\n        this._setBounds();\r\n    }\r\n\r\n    get pos() {\r\n        return this._pos;\r\n    }\r\n\r\n    set pos(value:Vector) {\r\n        var pos = this._pos;\r\n        pos.copy(value);\r\n        this._setBounds();\r\n    }\r\n\r\n    updatePos(value?:Vector) {\r\n        super.updatePos(value);\r\n        this._setBounds();\r\n    }\r\n\r\n    _setBounds() {\r\n        let pos = this._pos;\r\n        var bounds = this._bounds;\r\n        var radius = this._radius;\r\n        bounds.minX = pos.x - radius;\r\n        bounds.minY = pos.y - radius;\r\n        bounds.maxX = pos.x + radius;\r\n        bounds.maxY = pos.y + radius;\r\n    }\r\n}","import { Obj } from \"./object\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport class Rectangle extends Obj {\r\n    private _width:number;\r\n    private _height:number;\r\n    static POINT_COUNT:number = 4;\r\n    private _points:Vector[];\r\n    constructor() {\r\n        super();\r\n        this._width = 0;\r\n        this._height = 0;\r\n        let points:Vector[] = [];\r\n        this._points = points;\r\n        const POINT_COUNT = Rectangle.POINT_COUNT;\r\n        points.length = POINT_COUNT;\r\n        for (let i = 0; i < POINT_COUNT; ++i) {\r\n            points[i] = new Vector();\r\n        }\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    set width(value:number) {\r\n        this._width = value;\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get height() {\r\n        return this._height;\r\n    }\r\n\r\n    set height(value:number) {\r\n        this._height = value;\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get pos() {\r\n        return this._pos;\r\n    }\r\n\r\n    set pos(value:Vector) {\r\n        var pos = this._pos;\r\n        pos.copy(value);\r\n        \r\n        this._setBounds();\r\n        this._setPoints();\r\n        \r\n    }\r\n\r\n    updatePos(value?:Vector) {\r\n        super.updatePos(value);\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get points() {\r\n        return this._points;\r\n    }\r\n\r\n    _setBounds() {\r\n        let pos = this._pos;\r\n        let bounds = this._bounds;\r\n        let halfWidth = this._width / 2;\r\n        let halfHeight = this._height / 2;\r\n        bounds.minX = pos.x - halfWidth;\r\n        bounds.minY = pos.y - halfHeight;\r\n        bounds.maxX = pos.x + halfWidth;\r\n        bounds.maxY = pos.y + halfHeight;\r\n    }\r\n\r\n    _setPoints() {\r\n        let bounds = this._bounds;\r\n        let points = this._points;\r\n        //0 is 0(y)0(x)\r\n        points[0].x = bounds.minX;\r\n        points[0].y = bounds.minY;\r\n        //1 is 0(y)1(x)\r\n        points[1].x = bounds.maxX;\r\n        points[1].y = bounds.minY;\r\n        //3 is 1(y)1(x)\r\n        points[3].x = bounds.maxX;\r\n        points[3].y = bounds.maxY;\r\n        //2 is 1(y)0(x)\r\n        points[2].x = bounds.minX;\r\n        points[2].y = bounds.maxY;\r\n    }\r\n}","import { Circle } from \"./circle\";\r\nimport { Obj } from \"./object\";\r\nimport { Rectangle } from \"./rectangle\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport interface ICollideResult {\r\n    collided: boolean; normal:Vector;\r\n}\r\n\r\nexport class MyCircle extends Circle {\r\n\r\n    private _velocity:Vector;\r\n\r\n    constructor() {\r\n        super();\r\n        this._velocity = new Vector();\r\n\r\n    }\r\n\r\n    get velocity():Vector {\r\n        return this._velocity;\r\n    }\r\n\r\n    set velocity(value:Vector) {\r\n        this._velocity = value;\r\n    }\r\n\r\n    collide(target:Obj, result?:ICollideResult) {\r\n        if (result == null) result = {\r\n                collided: false,\r\n                normal: new Vector(),\r\n            };\r\n        else {\r\n            result.collided = false;\r\n        }\r\n        if (target instanceof Circle) {\r\n            let myCircle = this;\r\n            let targetCircle = target as Circle;\r\n            if (myCircle.bounds.intersect(targetCircle.bounds)) {\r\n                let normal = Vector.subVectors(myCircle.pos, targetCircle.pos);\r\n                let distance = normal.magnitude();\r\n                if (distance < (myCircle.radius + targetCircle.radius)) {\r\n                    result.collided = true;\r\n                    normal.normal();\r\n                    result.normal.copy(normal);\r\n                }\r\n            }\r\n        } else if (target instanceof Rectangle) {\r\n            let myCircle = this;\r\n            let targetSquare = target as Rectangle;\r\n            if (myCircle.bounds.intersect(targetSquare.bounds)) {\r\n                let circleCenter = myCircle.pos;\r\n                let circleCenterX = circleCenter.x;\r\n                let circleCenterY = circleCenter.y;\r\n                let circleRadius = myCircle.radius;\r\n                let squareBounds = targetSquare.bounds;\r\n\r\n                //00 is left 01 is midle 10 is right\r\n                //First two bit is x and second two bit is y.\r\n                let circlArea = 0;\r\n\r\n                if (circleCenterX > squareBounds.minX && circleCenterX < squareBounds.maxX) {\r\n                    circlArea |= 1;\r\n                } else if (circleCenterX > squareBounds.maxX) {\r\n                    circlArea |= 2;\r\n                }\r\n\r\n                if (circleCenterY > squareBounds.minY && circleCenterY < squareBounds.maxY) {\r\n                    circlArea |= (1 << 2);\r\n                } else if (circleCenterY > squareBounds.maxY) {\r\n                    circlArea |= (2 << 2);\r\n                }\r\n\r\n                //rectangle 9 area.\r\n                let findArea = false;\r\n                for (let areaX = 0; areaX < 3; ++areaX) {\r\n                    for (let areaY = 0; areaY < 3; ++areaY) {\r\n                        if ((circlArea ^ areaX) == 0 && ((circlArea >> 2) ^ areaY) == 0) {\r\n                            findArea = true;\r\n                            //There 3 possible condition for each area.\r\n                            if (areaX == 1 && areaY == 1) {\r\n                                //The center is inside the bounds (namely, inside the square).\r\n                                result.collided = true;\r\n                                Vector.normalVector(myCircle.velocity, result.normal);\r\n                            } else if (areaX != 1 && areaY != 1) {\r\n                                //The circle is corner of the square.\r\n                                //Detect if any point of square is inside the circle.\r\n                                let points = targetSquare.points;\r\n                                let point = points[((areaY >> 1) << 1) | (areaX >> 1)];\r\n                                let pointHelper = new Vector();\r\n                                let circleRadiusSquare:number = circleRadius * circleRadius;\r\n                                Vector.subVectors(circleCenter, point, pointHelper);\r\n                                if (pointHelper.manitudeSquare() < circleRadiusSquare) {\r\n                                    //The point is inside the circle.\r\n                                    result.collided = true;\r\n                                    Vector.normalVector(pointHelper, result.normal);\r\n                                }  \r\n                            } else {\r\n                                result.collided = true;\r\n                                result.normal = new Vector(areaX - 1, areaY - 1);\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (findArea) break;\r\n                }\r\n\r\n\r\n                // if (circleCenterX > squareBounds.minX && circleCenterX < squareBounds.maxX) {\r\n                //     if (circleCenterY > squareBounds.minY && circleCenterY < squareBounds.maxY) {\r\n                //         //The center is inside the bounds (namely, inside the square).\r\n                //         result.collided = true;\r\n                //         Vector.normalVector(myCircle.velocity, result.normal);\r\n                //     } else if (circleCenterY > squareBounds.maxY) {\r\n                //         //The center is downside the bounds.\r\n                //         if (circleCenterY - squareBounds.maxY < circleRadius) {\r\n                //             result.collided = true;\r\n                //             result.normal = new Vector(0, 1);\r\n                //         }\r\n\r\n                //     } else if (circleCenterY < squareBounds.minY) {\r\n                //         //The center is upside the bounds.\r\n                //         if (squareBounds.minY - circleCenterY < circleRadius) {\r\n                //             result.collided = true;\r\n                //             result.normal = new Vector(0, -1);\r\n                //         }\r\n                //     }\r\n                // } else if (circleCenterY > squareBounds.minY && circleCenterY < squareBounds.maxY) {\r\n                //     if (circleCenterX > squareBounds.maxX) {\r\n                //         //The center is right of the bounds.\r\n                //         if (circleCenterX - squareBounds.maxX < circleRadius) {\r\n                //             result.collided = true;\r\n                //             result.normal = new Vector(1, 0);\r\n                //         }\r\n                //     } else if (circleCenterX < squareBounds.minX) {\r\n                //         //The center is left of the bounds.\r\n                //         if (squareBounds.minX - circleCenterX < circleRadius) {\r\n                //             result.collided = true;\r\n                //             result.normal = new Vector(-1, 0);\r\n                //         }\r\n                //     }\r\n                // } else {\r\n                //     //Detect if any point of square is inside the circle.\r\n                //     let points = targetSquare.points;\r\n                //     let pointCount = points.length;\r\n                //     let pointHelper:Vector = new Vector();\r\n                //     let circleRadiusSquare:number = circleRadius * circleRadius;\r\n                //     for (let i = 0; i < pointCount; ++i) {\r\n                //         Vector.subVectors(circleCenter, points[i], pointHelper);\r\n                //         if (pointHelper.manitudeSquare() < circleRadiusSquare) {\r\n                //             //The point is inside the circle.\r\n                //             result.collided = true;\r\n                //             Vector.normalVector(pointHelper, result.normal);\r\n                //             break;\r\n                //         }\r\n                //     }\r\n                // }\r\n            }\r\n        } else {\r\n            throw new Error(\"Invalid shape for collision detection.\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n}","export * from \"./vector\";\r\nexport * from \"./bounds\";\r\nexport * from \"./object\";\r\nexport * from \"./circle\";\r\nexport * from \"./rectangle\";\r\nexport * from \"./world\";\r\nexport * from \"./my_circle\";\r\n","import { Obj } from \"./object\";\r\nimport { Vector } from \"./vector\";\r\nimport { MyCircle, ICollideResult } from \"./my_circle\";\r\n\r\nexport class World {\r\n\r\n    time:number;\r\n    objectCount:number;\r\n    objects: Obj[];\r\n    myObj:MyCircle;\r\n\r\n    constructor() {\r\n        this.time = 0;\r\n        this.objectCount = 0;\r\n        this.objects = [];\r\n        this.myObj = new MyCircle();\r\n    }\r\n\r\n    addObj(object:Obj) {\r\n        if (this.objectCount < this.objects.length) {\r\n            this.objects[this.objectCount++] = object;\r\n        }\r\n        else {\r\n            this.objects.length = 2 * this.objects.length;\r\n            this.objects[this.objectCount++] = object;\r\n        }\r\n    }\r\n\r\n    removeObj(object:Obj) {\r\n        let objectCount = this.objectCount;\r\n        let objects = this.objects;\r\n        for (let i = 0; i < objectCount; ++i) {\r\n            if (object == objects[i]) {\r\n                --objectCount;\r\n                if (i < objectCount) {\r\n                    objects[i] = objects[objectCount];\r\n                    objects[objectCount] = null;\r\n                }\r\n\r\n                this.objectCount = objectCount;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        this.objectCount = 0;\r\n    }\r\n\r\n    get myObject() {\r\n        return this.myObj;\r\n    }\r\n\r\n    step(dt: number, iterations: number):void {\r\n\r\n        dt = dt || 0;\r\n        iterations = iterations || 1;\r\n\r\n        let cachePosHelper:Vector = new Vector();\r\n        let nextPosHelper:Vector = new Vector();\r\n        let collisionResultHelper:ICollideResult = { collided:false, normal: new Vector()};\r\n        let collisionNormlHelper:Vector = new Vector();\r\n        let reflectResultHelper:Vector = new Vector();\r\n\r\n        let minDt:number = dt / iterations;\r\n        for (let iteration = 0; iteration < iterations; ++iteration) {\r\n            let objectCount = this.objectCount;\r\n            let objects = this.objects;\r\n            let myBody = this.myObj;\r\n\r\n            //Cache current position.\r\n            let cachePos = cachePosHelper;\r\n            cachePos.copy(myBody.pos);\r\n\r\n            //Caculate next position.\r\n            let nextPos = nextPosHelper;\r\n            nextPos.x = myBody.pos.x + myBody.velocity.x * minDt;\r\n            nextPos.y = myBody.pos.y + myBody.velocity.y * minDt;\r\n            myBody.pos = nextPos;\r\n\r\n            //Detect collision.\r\n            let collisioned = false;\r\n            let collisionResult = collisionResultHelper;\r\n            let collsionNormal = collisionNormlHelper;\r\n            collsionNormal.zero();\r\n            for (let i = 0; i < objectCount; ++i) {\r\n                let object = objects[i];\r\n                myBody.collide(object, collisionResult);\r\n                if (collisionResult.collided) {\r\n                    collisioned = true;\r\n                    collsionNormal.add(collisionResult.normal);\r\n                }\r\n            }\r\n\r\n            //Final collsion result.\r\n            let reflectResult = reflectResultHelper;\r\n            if (collisioned) {\r\n                //Recover to cached pre postion.\r\n                myBody.pos = cachePos;\r\n                let cacheMagnitude = myBody.velocity.magnitude();\r\n                //Set new velocity according to collision normal.\r\n                Vector.reflectVector(myBody.velocity, collsionNormal, reflectResult);\r\n                // if (Math.abs(reflectResult.magnitude() - myBody.velocity.magnitude()) > 10) \r\n                //     throw new Error('Velocity is changed!');\r\n                // myBody.velocity.copy(reflectResult);\r\n\r\n                reflectResult.normal();\r\n                reflectResult.mulMag(cacheMagnitude);\r\n                myBody.velocity.copy(reflectResult);\r\n\r\n                //Move\r\n                let nextPos = nextPosHelper;\r\n                nextPos.x = myBody.pos.x + myBody.velocity.x * minDt;\r\n                nextPos.y = myBody.pos.y + myBody.velocity.y * minDt;\r\n                myBody.pos = nextPos;\r\n            }\r\n        }\r\n\r\n        this.time += dt;\r\n    }\r\n}"],"sourceRoot":""}