{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/vector.ts","webpack:///./src/object.ts","webpack:///./src/rectangle.ts","webpack:///./src/bounds.ts","webpack:///./src/circle.ts","webpack:///./src/triangle.ts","webpack:///./src/index.ts","webpack:///./src/world.ts","webpack:///./node_modules/eventemitter3/index.js","webpack:///./src/my_circle.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vector","x","y","this","subVectors","vec1","vec2","result","addVectors","mulVectorMag","vec","magnitude","normalVector","copy","clone","normal","dotVectors","reflectVector","Error","dot","mulMag","target","sub","add","Math","sqrt","manitudeSquare","zero","vector_1","bounds_1","Obj","_pos","_bounds","Bounds","updatePos","object_1","Rectangle","_super","_this","_width","_height","points","_points","POINT_COUNT","length","_setBounds","_setPoints","__extends","pos","bounds","halfWidth","halfHeight","minX","minY","maxX","maxY","intersectBounds","bounds1","bounds2","intersect","Circle","_radius","radius","rectangle_1","DirectIRTriangle","IRTriangle","_size","halfSize","__export","World","time","objectCount","objects","myCircleCount","myCircles","addObj","removeObj","clearObjs","addMyCircle","myCircle","removeMyCircle","clearMyCircles","step","dt","iterations","cachePosHelper","nextPosHelper","collisionResultHelper","collided","collisionNormlHelper","reflectResultHelper","minDt","iteration","myCircleIndex","myBody","cachePos","nextPos","velocity","collisionResult","collsionNormal","collide","emit","reflectResult","cacheMagnitude","nextPos_1","EventEmitter","has","prefix","Events","addListener","emitter","event","fn","context","once","TypeError","listener","evt","_events","push","_eventsCount","clearEvent","__proto__","eventNames","events","names","slice","getOwnPropertySymbols","concat","listeners","handlers","ee","Array","listenerCount","a1","a2","a3","a4","a5","args","len","arguments","removeListener","undefined","apply","j","on","removeAllListeners","off","prefixed","circle_1","triangle_1","MyCircle","_velocity","targetCircle","targetSquare","circleCenterX","circleCenter","circleCenterY","circleRadius","squareBounds","pointCount","pointHelper","circleRadiusSquare","targetTriangle","circleCenterPos","triangleBounds","triangleBoundsMin","triangleBoundsMax","circlArea","findArea","areaX","areaY","sameXDirect","direct","sameYDirect","point","abs","vectorTriangleToCenter"],"mappings":"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","file":"model.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","export class Vector {\r\n    public static subVectors(vec1:Vector, vec2:Vector, result?:Vector):Vector {\r\n        if (! result) result = new Vector();\r\n        result.x = vec1.x - vec2.x;\r\n        result.y = vec1.y - vec2.y;\r\n        return result;\r\n    }\r\n\r\n    public static addVectors(vec1:Vector, vec2:Vector, result?:Vector):Vector {\r\n        if (! result) result = new Vector();\r\n        result.x = vec1.x + vec2.x;\r\n        result.y = vec1.y + vec2.y;\r\n        return result;\r\n    }\r\n\r\n    public static mulVectorMag(vec:Vector, magnitude:number, result?:Vector):Vector {\r\n        if (! result) result = new Vector();\r\n        result.x = vec.x * magnitude;\r\n        result.y = vec.y * magnitude;\r\n        return result;\r\n    }\r\n\r\n    public static normalVector(vec:Vector, result?:Vector):Vector {\r\n        if (! result) result = vec.clone();\r\n        else result.copy(vec);\r\n        result.normal();\r\n        return result;\r\n    }\r\n\r\n    public static dotVectors(vec1:Vector, vec2:Vector):number {\r\n        return vec1.x * vec2.x + vec1.y * vec2.y;\r\n    }\r\n\r\n    public static reflectVector(vec:Vector, normal:Vector, result?:Vector):Vector {\r\n        if (! result) result = new Vector();\r\n        else if (result == vec) {\r\n            throw new Error(\"The result shouldn't be argument vec.\");\r\n        }\r\n        let dot = Vector.dotVectors(vec, normal);\r\n        result.copy(normal);\r\n        result.mulMag(dot * 2);\r\n        Vector.subVectors(vec, result, result);\r\n        return result;\r\n    }\r\n\r\n    x:number;\r\n    y:number;\r\n    constructor(x:number = 0, y:number = 0) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    clone():Vector {\r\n        return new Vector(this.x, this.y);\r\n    }\r\n\r\n    copy(target:Vector):void {\r\n        this.x = target.x;\r\n        this.y = target.y;\r\n    }\r\n\r\n    sub(target:Vector):void {\r\n        this.x -= target.x;\r\n        this.y -= target.y;\r\n    }\r\n\r\n    add(target:Vector):void {\r\n        this.x += target.x;\r\n        this.y += target.y;\r\n    }\r\n\r\n    mulMag(magnitude:number):void {\r\n        this.x *= magnitude;\r\n        this.y *= magnitude;\r\n    }\r\n\r\n    magnitude():number {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        return Math.sqrt(x * x + y * y);\r\n    }\r\n\r\n    manitudeSquare():number {\r\n        var x = this.x;\r\n        var y = this.y;\r\n        return x * x + y * y;\r\n    }\r\n\r\n    normal():void {\r\n        let magnitude = this.magnitude();\r\n        this.x /= magnitude;\r\n        this.y /= magnitude;\r\n    }\r\n\r\n    zero():void {\r\n        this.x = 0;\r\n        this.y = 0;\r\n    }\r\n}","import { Vector } from \"./vector\";\r\nimport { Bounds } from \"./bounds\";\r\n\r\nexport abstract class Obj {\r\n    protected _pos:Vector;\r\n    protected _bounds:Bounds;\r\n    constructor() {\r\n        this._pos = new Vector();\r\n        this._bounds = new Bounds();\r\n    }\r\n\r\n    get pos():Vector {\r\n        return this._pos;\r\n    }\r\n\r\n    set pos(value:Vector) {\r\n        this._pos.copy(value);\r\n    }\r\n\r\n    get bounds():Bounds {\r\n        return this._bounds;\r\n    }\r\n\r\n    updatePos(value?:Vector) {\r\n        if (value) {\r\n            this._pos = value;\r\n        }\r\n    }\r\n}","import { Obj } from \"./object\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport class Rectangle extends Obj {\r\n    private _width:number;\r\n    private _height:number;\r\n    static POINT_COUNT:number = 4;\r\n    private _points:Vector[];\r\n    constructor() {\r\n        super();\r\n        this._width = 0;\r\n        this._height = 0;\r\n        let points:Vector[] = [];\r\n        this._points = points;\r\n        const POINT_COUNT = Rectangle.POINT_COUNT;\r\n        points.length = POINT_COUNT;\r\n        for (let i = 0; i < POINT_COUNT; ++i) {\r\n            points[i] = new Vector();\r\n        }\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    set width(value:number) {\r\n        this._width = value;\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get height() {\r\n        return this._height;\r\n    }\r\n\r\n    set height(value:number) {\r\n        this._height = value;\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get pos() {\r\n        return this._pos;\r\n    }\r\n\r\n    set pos(value:Vector) {\r\n        var pos = this._pos;\r\n        pos.copy(value);\r\n        \r\n        this._setBounds();\r\n        this._setPoints();\r\n        \r\n    }\r\n\r\n    updatePos(value?:Vector) {\r\n        super.updatePos(value);\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get points() {\r\n        return this._points;\r\n    }\r\n\r\n    _setBounds() {\r\n        let pos = this._pos;\r\n        let bounds = this._bounds;\r\n        let halfWidth = this._width / 2;\r\n        let halfHeight = this._height / 2;\r\n        bounds.minX = pos.x - halfWidth;\r\n        bounds.minY = pos.y - halfHeight;\r\n        bounds.maxX = pos.x + halfWidth;\r\n        bounds.maxY = pos.y + halfHeight;\r\n    }\r\n\r\n    _setPoints() {\r\n        let bounds = this._bounds;\r\n        let points = this._points;\r\n        //0 is 0(y)0(x)\r\n        points[0].x = bounds.minX;\r\n        points[0].y = bounds.minY;\r\n        //1 is 0(y)1(x)\r\n        points[1].x = bounds.maxX;\r\n        points[1].y = bounds.minY;\r\n        //3 is 1(y)1(x)\r\n        points[3].x = bounds.maxX;\r\n        points[3].y = bounds.maxY;\r\n        //2 is 1(y)0(x)\r\n        points[2].x = bounds.minX;\r\n        points[2].y = bounds.maxY;\r\n    }\r\n}","export class Bounds {\r\n    public static intersectBounds(bounds1:Bounds, bounds2:Bounds):boolean {\r\n        if (bounds1.minX > bounds2.maxX || bounds1.maxX < bounds2.minX || \r\n            bounds1.minY > bounds2.maxY || bounds1.maxY < bounds2.minY) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    minX:number;\r\n    minY:number;\r\n    maxX:number;\r\n    maxY:number;\r\n    constructor(minX:number = 0, minY:number = 0, maxX:number = 0, maxY:number = 0) {\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    }\r\n\r\n    intersect(target:Bounds):boolean {\r\n        return Bounds.intersectBounds(this, target);\r\n    }\r\n}","import { Obj } from \"./object\";\r\nimport { Bounds } from \"./bounds\";\r\nimport { Vector } from \"./vector\";\r\n\r\nexport class Circle extends Obj {\r\n    private _radius:number;\r\n    constructor() {\r\n        super();\r\n        this._radius = 0;\r\n        this._setBounds();\r\n    }\r\n\r\n    get radius():number {\r\n        return this._radius;\r\n    }\r\n\r\n    set radius(value:number) {\r\n        this._radius = value;\r\n        this._setBounds();\r\n    }\r\n\r\n    get pos() {\r\n        return this._pos;\r\n    }\r\n\r\n    set pos(value:Vector) {\r\n        var pos = this._pos;\r\n        pos.copy(value);\r\n        this._setBounds();\r\n    }\r\n\r\n    updatePos(value?:Vector) {\r\n        super.updatePos(value);\r\n        this._setBounds();\r\n    }\r\n\r\n    _setBounds() {\r\n        let pos = this._pos;\r\n        var bounds = this._bounds;\r\n        var radius = this._radius;\r\n        bounds.minX = pos.x - radius;\r\n        bounds.minY = pos.y - radius;\r\n        bounds.maxX = pos.x + radius;\r\n        bounds.maxY = pos.y + radius;\r\n    }\r\n}","import { Obj } from \"./object\";\r\nimport { Vector } from \"./vector\";\r\nimport { Rectangle } from \"./rectangle\";\r\n\r\n//Right angle direct.\r\nexport enum DirectIRTriangle {\r\n    LEFT_UP = 0,\r\n    RIGHT_UP = 1,\r\n    RIGHT_BOTTOM = 3,\r\n    LEFT_BOTTOM = 2,\r\n}\r\n\r\nexport class IRTriangle extends Obj {\r\n    public direct:DirectIRTriangle;\r\n    private _size:number;\r\n    static POINT_COUNT:number = 4;\r\n    private _points:Vector[];\r\n    constructor() {\r\n        super();\r\n        this._size = 0;\r\n        let points:Vector[] = [];\r\n        this._points = points;\r\n        const POINT_COUNT = Rectangle.POINT_COUNT;\r\n        points.length = POINT_COUNT;\r\n        for (let i = 0; i < POINT_COUNT; ++i) {\r\n            points[i] = new Vector();\r\n        }\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get size() {\r\n        return this._size;\r\n    }\r\n\r\n    set size(value:number) {\r\n        this._size = value;\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get pos() {\r\n        return this._pos;\r\n    }\r\n\r\n    set pos(value:Vector) {\r\n        var pos = this._pos;\r\n        pos.copy(value);\r\n        \r\n        this._setBounds();\r\n        this._setPoints();\r\n        \r\n    }\r\n\r\n    updatePos(value?:Vector) {\r\n        super.updatePos(value);\r\n        this._setBounds();\r\n        this._setPoints();\r\n    }\r\n\r\n    get points() {\r\n        return this._points;\r\n    }\r\n\r\n    _setBounds() {\r\n        let pos = this._pos;\r\n        let bounds = this._bounds;\r\n        let halfSize = this._size / 2;\r\n        bounds.minX = pos.x - halfSize;\r\n        bounds.minY = pos.y - halfSize;\r\n        bounds.maxX = pos.x + halfSize;\r\n        bounds.maxY = pos.y + halfSize;\r\n    }\r\n\r\n    _setPoints() {\r\n        let bounds = this._bounds;\r\n        let points = this._points;\r\n        //0 is 0(y)0(x)\r\n        points[0].x = bounds.minX;\r\n        points[0].y = bounds.minY;\r\n        //1 is 0(y)1(x)\r\n        points[1].x = bounds.maxX;\r\n        points[1].y = bounds.minY;\r\n        //3 is 1(y)1(x)\r\n        points[3].x = bounds.maxX;\r\n        points[3].y = bounds.maxY;\r\n        //2 is 1(y)0(x)\r\n        points[2].x = bounds.minX;\r\n        points[2].y = bounds.maxY;\r\n    }\r\n}","export * from \"./vector\";\r\nexport * from \"./bounds\";\r\nexport * from \"./object\";\r\nexport * from \"./circle\";\r\nexport * from \"./rectangle\";\r\nexport * from \"./triangle\";\r\nexport * from \"./world\";\r\nexport * from \"./my_circle\";\r\n","import { Obj } from \"./object\";\r\nimport { Vector } from \"./vector\";\r\nimport { MyCircle, ICollideResult } from \"./my_circle\";\r\nimport * as eventemitter3 from \"eventemitter3\";\r\n\r\nexport class World extends eventemitter3.EventEmitter {\r\n\r\n    time:number;\r\n    objectCount:number;\r\n    objects: Obj[];\r\n    myCircleCount:number;\r\n    myCircles:MyCircle[];\r\n\r\n    constructor() {\r\n        super()\r\n        this.time = 0;\r\n        this.objectCount = 0;\r\n        this.objects = [];\r\n        this.myCircleCount = 0;\r\n        this.myCircles = [];\r\n    }\r\n\r\n    addObj(object:Obj) {\r\n        if (this.objectCount < this.objects.length) {\r\n            this.objects[this.objectCount++] = object;\r\n        }\r\n        else {\r\n            this.objects.length = 2 * this.objects.length;\r\n            this.objects[this.objectCount++] = object;\r\n        }\r\n    }\r\n\r\n    removeObj(object:Obj) {\r\n        let objectCount = this.objectCount;\r\n        let objects = this.objects;\r\n        for (let i = 0; i < objectCount; ++i) {\r\n            if (object == objects[i]) {\r\n                --objectCount;\r\n                if (i < objectCount) {\r\n                    objects[i] = objects[objectCount];\r\n                    objects[objectCount] = null;\r\n                }\r\n\r\n                this.objectCount = objectCount;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    clearObjs() {\r\n        this.objectCount = 0;\r\n    }\r\n\r\n    addMyCircle(myCircle:MyCircle) {\r\n        if (this.myCircleCount < this.myCircles.length) {\r\n            this.myCircles[this.myCircleCount++] = myCircle;\r\n        }\r\n        else {\r\n            this.myCircles.length = 2 * this.myCircles.length;\r\n            this.myCircles[this.myCircleCount++] = myCircle;\r\n        }\r\n    }\r\n\r\n    removeMyCircle(myCircle:MyCircle) {\r\n        let myCircleCount = this.myCircleCount;\r\n        let myCircles = this.myCircles;\r\n        for (let i = 0; i < myCircleCount; ++i) {\r\n            if (myCircle == myCircles[i]) {\r\n                --myCircleCount;\r\n                if (i < myCircleCount) {\r\n                    myCircles[i] = myCircles[myCircleCount];\r\n                    myCircles[myCircleCount] = null;\r\n                }\r\n\r\n                this.myCircleCount = myCircleCount;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    clearMyCircles() {\r\n        this.myCircleCount = 0;\r\n    }\r\n\r\n    step(dt: number, iterations: number):void {\r\n\r\n        dt = dt || 0;\r\n        iterations = iterations || 1;\r\n\r\n        let cachePosHelper:Vector = new Vector();\r\n        let nextPosHelper:Vector = new Vector();\r\n        let collisionResultHelper:ICollideResult = { collided:false, normal: new Vector()};\r\n        let collisionNormlHelper:Vector = new Vector();\r\n        let reflectResultHelper:Vector = new Vector();\r\n\r\n        let minDt:number = dt / iterations;\r\n        for (let iteration = 0; iteration < iterations; ++iteration) {\r\n            let myCircleCount = this.myCircleCount;\r\n            let myCircles = this.myCircles;\r\n            for (let myCircleIndex = 0; myCircleIndex < myCircleCount; ++myCircleIndex) {\r\n                let objectCount = this.objectCount;\r\n                let objects = this.objects;\r\n                let myBody = myCircles[myCircleIndex];\r\n    \r\n                //Cache current position.\r\n                let cachePos = cachePosHelper;\r\n                cachePos.copy(myBody.pos);\r\n    \r\n                //Caculate next position.\r\n                let nextPos = nextPosHelper;\r\n                nextPos.x = myBody.pos.x + myBody.velocity.x * minDt;\r\n                nextPos.y = myBody.pos.y + myBody.velocity.y * minDt;\r\n                myBody.pos = nextPos;\r\n    \r\n                //Detect collision.\r\n                let collided = false;\r\n                let collisionResult = collisionResultHelper;\r\n                let collsionNormal = collisionNormlHelper;\r\n                collsionNormal.zero();\r\n                for (let i = 0; i < objectCount; ++i) {\r\n                    let object = objects[i];\r\n                    myBody.collide(object, collisionResult);\r\n                    if (collisionResult.collided) {\r\n                        collided = true;\r\n                        collsionNormal.add(collisionResult.normal);\r\n                        this.emit(\"collided\", object);\r\n                    }\r\n                }\r\n    \r\n                //Final collsion result.\r\n                let reflectResult = reflectResultHelper;\r\n                if (collided) {\r\n                    //Recover to cached pre postion.\r\n                    myBody.pos = cachePos;\r\n                    let cacheMagnitude = myBody.velocity.magnitude();\r\n                    //Set new velocity according to collision normal.\r\n                    Vector.reflectVector(myBody.velocity, collsionNormal, reflectResult);\r\n\r\n                    // if (Math.abs(reflectResult.magnitude() - myBody.velocity.magnitude()) > 10) \r\n                    //     throw new Error('Velocity is changed!');\r\n                    // myBody.velocity.copy(reflectResult);\r\n    \r\n                    reflectResult.normal();\r\n                    reflectResult.mulMag(cacheMagnitude);\r\n                    myBody.velocity.copy(reflectResult);\r\n    \r\n                    //Move\r\n                    let nextPos = nextPosHelper;\r\n                    nextPos.x = myBody.pos.x + myBody.velocity.x * minDt;\r\n                    nextPos.y = myBody.pos.y + myBody.velocity.y * minDt;\r\n                    myBody.pos = nextPos;\r\n\r\n                }\r\n            }\r\n\r\n            \r\n        }\r\n\r\n        this.time += dt;\r\n    }\r\n}","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import { Circle } from \"./circle\";\r\nimport { Obj } from \"./object\";\r\nimport { Rectangle } from \"./rectangle\";\r\nimport { Vector } from \"./vector\";\r\nimport { IRTriangle } from \"./triangle\";\r\n\r\nexport interface ICollideResult {\r\n    collided: boolean; normal:Vector;\r\n}\r\n\r\nexport class MyCircle extends Circle {\r\n\r\n    private _velocity:Vector;\r\n\r\n    constructor() {\r\n        super();\r\n        this._velocity = new Vector();\r\n\r\n    }\r\n\r\n    get velocity():Vector {\r\n        return this._velocity;\r\n    }\r\n\r\n    set velocity(value:Vector) {\r\n        this._velocity = value;\r\n    }\r\n\r\n    collide(target:Obj, result?:ICollideResult) {\r\n        if (result == null) result = {\r\n                collided: false,\r\n                normal: new Vector(),\r\n            };\r\n        else {\r\n            result.collided = false;\r\n        }\r\n        if (target instanceof Circle) {\r\n            let myCircle = this;\r\n            let targetCircle = target as Circle;\r\n            if (myCircle.bounds.intersect(targetCircle.bounds)) {\r\n                let normal = Vector.subVectors(myCircle.pos, targetCircle.pos);\r\n                let distance = normal.magnitude();\r\n                if (distance < (myCircle.radius + targetCircle.radius)) {\r\n                    result.collided = true;\r\n                    normal.normal();\r\n                    result.normal.copy(normal);\r\n                }\r\n            }\r\n        } else if (target instanceof Rectangle) {\r\n            let myCircle = this;\r\n            let targetSquare = target as Rectangle;\r\n            if (myCircle.bounds.intersect(targetSquare.bounds)) {\r\n                let circleCenter = myCircle.pos;\r\n                let circleCenterX = circleCenter.x;\r\n                let circleCenterY = circleCenter.y;\r\n                let circleRadius = myCircle.radius;\r\n                let squareBounds = targetSquare.bounds;\r\n                if (circleCenterX > squareBounds.minX && circleCenterX < squareBounds.maxX) {\r\n                    if (circleCenterY > squareBounds.minY && circleCenterY < squareBounds.maxY) {\r\n                        //The center is inside the bounds (namely, inside the square).\r\n                        result.collided = true;\r\n                        Vector.normalVector(myCircle.velocity, result.normal);\r\n                    } else if (circleCenterY > squareBounds.maxY) {\r\n                        //The center is downside the bounds.\r\n                        if (circleCenterY - squareBounds.maxY < circleRadius) {\r\n                            result.collided = true;\r\n                            result.normal = new Vector(0, 1);\r\n                        }\r\n\r\n                    } else if (circleCenterY < squareBounds.minY) {\r\n                        //The center is upside the bounds.\r\n                        if (squareBounds.minY - circleCenterY < circleRadius) {\r\n                            result.collided = true;\r\n                            result.normal = new Vector(0, -1);\r\n                        }\r\n                    }\r\n                } else if (circleCenterY > squareBounds.minY && circleCenterY < squareBounds.maxY) {\r\n                    if (circleCenterX > squareBounds.maxX) {\r\n                        //The center is right of the bounds.\r\n                        if (circleCenterX - squareBounds.maxX < circleRadius) {\r\n                            result.collided = true;\r\n                            result.normal = new Vector(1, 0);\r\n                        }\r\n                    } else if (circleCenterX < squareBounds.minX) {\r\n                        //The center is left of the bounds.\r\n                        if (squareBounds.minX - circleCenterX < circleRadius) {\r\n                            result.collided = true;\r\n                            result.normal = new Vector(-1, 0);\r\n                        }\r\n                    }\r\n                } else {\r\n                    //Detect if any point of square is inside the circle.\r\n                    let points = targetSquare.points;\r\n                    let pointCount = points.length;\r\n                    let pointHelper:Vector = new Vector();\r\n                    let circleRadiusSquare:number = circleRadius * circleRadius;\r\n                    for (let i = 0; i < pointCount; ++i) {\r\n                        Vector.subVectors(circleCenter, points[i], pointHelper);\r\n                        if (pointHelper.manitudeSquare() < circleRadiusSquare) {\r\n                            //The point is inside the circle.\r\n                            result.collided = true;\r\n                            Vector.normalVector(pointHelper, result.normal);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (target instanceof IRTriangle) {\r\n            let myCircle = this;\r\n            let targetTriangle = target as IRTriangle;\r\n            if (myCircle.bounds.intersect(targetTriangle.bounds)) {\r\n                let circleCenter = myCircle.pos;\r\n                let circleCenterPos = [circleCenter.x, circleCenter.y];\r\n                let circleRadius = myCircle.radius;\r\n                let triangleBounds = targetTriangle.bounds;\r\n                let triangleBoundsMin = [triangleBounds.minX, triangleBounds.minY];\r\n                let triangleBoundsMax = [triangleBounds.maxX, triangleBounds.maxY];\r\n                //00 is left 01 is midle 10 is right\r\n                //First two bit is x and second two bit is y.\r\n                let circlArea = 0;\r\n                if (circleCenterPos[0] > triangleBoundsMin[0] && circleCenterPos[0] < triangleBoundsMax[0]) {\r\n                    circlArea |= 1;\r\n                } else if (circleCenterPos[0] > triangleBoundsMax[0]) {\r\n                    circlArea |= 2;\r\n                }\r\n                if (circleCenterPos[1] > triangleBoundsMin[1] && circleCenterPos[1] < triangleBoundsMax[1]) {\r\n                    circlArea |= (1 << 2);\r\n                } else if (circleCenterPos[1] > triangleBoundsMax[1]) {\r\n                    circlArea |= (2 << 2);\r\n                }\r\n                //rectangle 9 area.\r\n                let findArea = false;\r\n                for (let areaX = 0; areaX < 3; ++areaX) {\r\n                    for (let areaY = 0; areaY < 3; ++areaY) {\r\n                        if (((circlArea & 3) ^ areaX) == 0 && ((circlArea >> 2) ^ areaY) == 0) {\r\n                            findArea = true;\r\n                            let sameXDirect = areaX != 1 && (areaX >> 1) == (targetTriangle.direct & 1);\r\n                            let sameYDirect = areaY != 1 && (areaY >> 1) == ((targetTriangle.direct >> 1) & 1);\r\n                            if (sameXDirect || sameYDirect) {\r\n                                if (areaX != 1 && areaY != 1) {\r\n                                    //The circle is corner of the square.\r\n                                    //Detect if any point of square is inside the circle.\r\n                                    let points = targetTriangle.points;\r\n                                    let point = points[((areaY >> 1) << 1) | (areaX >> 1)];\r\n                                    let pointHelper = new Vector();\r\n                                    let circleRadiusSquare:number = circleRadius * circleRadius;\r\n                                    Vector.subVectors(circleCenter, point, pointHelper);\r\n                                    if (pointHelper.manitudeSquare() < circleRadiusSquare) {\r\n                                        //The point is inside the circle.\r\n                                        result.collided = true;\r\n                                        Vector.normalVector(pointHelper, result.normal);\r\n                                    }  \r\n                                } else {\r\n                                    let points = targetTriangle.points;\r\n                                    //Right angle point.\r\n                                    let point = points[targetTriangle.direct];\r\n                                    if (areaX != 1) {\r\n                                        if (Math.abs(point.x - circleCenterPos[0]) < circleRadius) {\r\n                                            result.collided = true;\r\n                                            result.normal = new Vector(areaX - 1, 0);\r\n                                        }\r\n                                    } else {\r\n                                        if (Math.abs(point.y - circleCenterPos[1]) < circleRadius) {\r\n                                            result.collided = true;\r\n                                            result.normal = new Vector(0, areaY - 1);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                let vectorTriangleToCenter = Vector.subVectors(myCircle.pos, targetTriangle.pos);\r\n                                let points = targetTriangle.points;\r\n                                    //Right angle point.\r\n                                let point = points[targetTriangle.direct];\r\n                                let normal = Vector.subVectors(targetTriangle.pos, point);\r\n                                normal.normal();\r\n                                let dot = Vector.dotVectors(vectorTriangleToCenter, normal);\r\n                                let circleRadius = myCircle.radius;\r\n                                if (dot < circleRadius) {\r\n                                    result.collided = true;\r\n                                    result.normal = normal;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (findArea) break;\r\n                }\r\n            }\r\n            \r\n\r\n        } else {\r\n            throw new Error(\"Invalid shape for collision detection.\");\r\n        }\r\n\r\n        return result;\r\n    }\r\n}"],"sourceRoot":""}